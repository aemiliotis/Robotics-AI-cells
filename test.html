<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worm Wars - Tap to Navigate</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            background-color: #f0f0f0;
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border-radius: 5px;
        }
        
        #auth-screen, #game-screen, #leaderboard {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        h1, h2, h3 {
            margin-bottom: 15px;
        }
        
        form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        input, button {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 16px;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        #game-wrapper {
            position: relative;
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #e8f5e9;
            border: 2px solid #4CAF50;
            overflow: hidden;
            touch-action: manipulation;
        }
        
        #world-container {
            position: absolute;
            width: 50000px;
            height: 50000px;
            background-color: #e8f5e9;
        }
        
        #minimap-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #4CAF50;
            background-color: rgba(232, 245, 233, 0.7);
            z-index: 100;
            overflow: hidden;
        }
        
        #minimap {
            position: absolute;
            width: 50000px;
            height: 50000px;
            transform-origin: 0 0;
        }
        
        #viewport-indicator {
            position: absolute;
            border: 2px dashed rgba(76, 175, 80, 0.8);
            background-color: rgba(76, 175, 80, 0.2);
            z-index: 101;
        }
        
        .worm {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            z-index: 10;
        }
        
        .worm-head {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            z-index: 20;
            border: 2px solid white;
        }
        
        .food {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            z-index: 5;
        }
        
        #tap-indicator {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
            z-index: 50;
            pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #score-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 5px;
        }
        
        #food-count {
            font-weight: bold;
            color: #4CAF50;
        }
        
        #leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        #leaderboard-table th, #leaderboard-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        #leaderboard-table th {
            background-color: #4CAF50;
            color: white;
        }
        
        #leaderboard-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .error-message {
            color: #f44336;
            margin-top: 5px;
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            #game-wrapper {
                height: 400px;
            }
            
            #score-display {
                flex-direction: column;
                gap: 5px;
            }
            
            #minimap-container {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Worm Wars - Tap to Navigate</h1>
            <p>Tap anywhere on the field to change direction!</p>
        </header>
        
        <div id="auth-screen">
            <h2>Register or Login</h2>
            <div id="auth-tabs">
                <button id="show-register">Register</button>
                <button id="show-login">Login</button>
            </div>
            
            <form id="register-form" style="display: none;">
                <input type="text" id="reg-username" placeholder="Username" required>
                <input type="password" id="reg-password" placeholder="Password" required>
                <input type="password" id="reg-confirm" placeholder="Confirm Password" required>
                <button type="submit">Register</button>
                <div id="reg-error" class="error-message"></div>
            </form>
            
            <form id="login-form">
                <input type="text" id="login-username" placeholder="Username" required>
                <input type="password" id="login-password" placeholder="Password" required>
                <button type="submit">Login</button>
                <div id="login-error" class="error-message"></div>
            </form>
        </div>
        
        <div id="game-screen" style="display: none;">
            <h2>Welcome, <span id="player-name"></span>!</h2>
            <div id="score-display">
                <div>Your Score: <span id="player-score">0</span></div>
                <div>Position: <span id="player-position">0, 0</span></div>
                <div>Food: <span id="food-count">0</span></div>
                <div>Leader: <span id="leader-score">-</span></div>
            </div>
            
            <div id="game-wrapper">
                <div id="game-container">
                    <div id="world-container"></div>
                    <div id="tap-indicator"></div>
                </div>
                <div id="minimap-container">
                    <div id="minimap"></div>
                    <div id="viewport-indicator"></div>
                </div>
            </div>
            
            <button id="logout-btn">Logout</button>
        </div>
        
        <div id="leaderboard">
            <h2>Leaderboard</h2>
            <table id="leaderboard-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Username</th>
                        <th>High Score</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <!-- Leaderboard data will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Game constants
        const WORLD_SIZE = 50000;
        const VIEWPORT_WIDTH = 800;  // Will be set dynamically
        const VIEWPORT_HEIGHT = 500; // Will be set dynamically
        const MINIMAP_SCALE = 0.003; // 150px / 50000px
        const INITIAL_FOOD = 500;    // 10x more food than before
        const FOOD_PER_EAT = 10;     // Add 10 new food when one is eaten

        // Game state
        const gameState = {
            players: {},
            foods: [],
            currentPlayer: null,
            socket: null,
            direction: 'right',
            targetDirection: 'right',
            targetPosition: null,
            keysPressed: {},
            gameLoopInterval: null,
            playerId: null,
            camera: { x: 0, y: 0 },
            worldOffset: { x: 0, y: 0 }
        };

        // DOM elements
        const elements = {
            authScreen: document.getElementById('auth-screen'),
            gameScreen: document.getElementById('game-screen'),
            registerForm: document.getElementById('register-form'),
            loginForm: document.getElementById('login-form'),
            showRegister: document.getElementById('show-register'),
            showLogin: document.getElementById('show-login'),
            regError: document.getElementById('reg-error'),
            loginError: document.getElementById('login-error'),
            playerName: document.getElementById('player-name'),
            playerScore: document.getElementById('player-score'),
            playerPosition: document.getElementById('player-position'),
            foodCount: document.getElementById('food-count'),
            leaderScore: document.getElementById('leader-score'),
            gameWrapper: document.getElementById('game-wrapper'),
            gameContainer: document.getElementById('game-container'),
            worldContainer: document.getElementById('world-container'),
            minimapContainer: document.getElementById('minimap-container'),
            minimap: document.getElementById('minimap'),
            viewportIndicator: document.getElementById('viewport-indicator'),
            tapIndicator: document.getElementById('tap-indicator'),
            leaderboardBody: document.getElementById('leaderboard-body'),
            logoutBtn: document.getElementById('logout-btn')
        };

        // Simulated database
        const database = {
            users: JSON.parse(localStorage.getItem('worm-wars-users')) || {},
            leaderboard: JSON.parse(localStorage.getItem('worm-wars-leaderboard')) || []
        };

        // Initialize game dimensions
        function initGameDimensions() {
            const rect = elements.gameContainer.getBoundingClientRect();
            gameState.viewportWidth = rect.width;
            gameState.viewportHeight = rect.height;
            
            // Set initial camera position to center of world
            gameState.camera.x = WORLD_SIZE / 2 - gameState.viewportWidth / 2;
            gameState.camera.y = WORLD_SIZE / 2 - gameState.viewportHeight / 2;
            
            // Update viewport indicator
            updateMinimap();
        }

        // Auth tab switching
        elements.showRegister.addEventListener('click', () => {
            elements.registerForm.style.display = 'flex';
            elements.loginForm.style.display = 'none';
        });

        elements.showLogin.addEventListener('click', () => {
            elements.loginForm.style.display = 'flex';
            elements.registerForm.style.display = 'none';
        });

        // Registration
        elements.registerForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = document.getElementById('reg-username').value;
            const password = document.getElementById('reg-password').value;
            const confirm = document.getElementById('reg-confirm').value;
            
            if (password !== confirm) {
                elements.regError.textContent = 'Passwords do not match';
                return;
            }
            
            if (database.users[username]) {
                elements.regError.textContent = 'Username already exists';
                return;
            }
            
            database.users[username] = { password, highScore: 0 };
            localStorage.setItem('worm-wars-users', JSON.stringify(database.users));
            elements.regError.textContent = '';
            alert('Registration successful! Please login.');
            elements.loginForm.style.display = 'flex';
            elements.registerForm.style.display = 'none';
            document.getElementById('login-username').value = username;
        });

        // Login
        elements.loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            
            if (!database.users[username]) {
                elements.loginError.textContent = 'Username not found';
                return;
            }
            
            if (database.users[username].password !== password) {
                elements.loginError.textContent = 'Incorrect password';
                return;
            }
            
            elements.loginError.textContent = '';
            loginUser(username);
        });

        // Logout
        elements.logoutBtn.addEventListener('click', () => {
            logoutUser();
        });

        // Tap to change direction
        elements.gameContainer.addEventListener('click', (e) => {
            if (!gameState.currentPlayer) return;
            
            // Get tap position relative to game container
            const rect = elements.gameContainer.getBoundingClientRect();
            const tapX = e.clientX - rect.left;
            const tapY = e.clientY - rect.top;
            
            // Convert to world coordinates
            const worldX = tapX + gameState.camera.x;
            const worldY = tapY + gameState.camera.y;
            
            // Store target position
            gameState.targetPosition = { x: worldX, y: worldY };
            
            // Show tap indicator
            elements.tapIndicator.style.left = `${tapX}px`;
            elements.tapIndicator.style.top = `${tapY}px`;
            elements.tapIndicator.style.opacity = '1';
            
            // Hide tap indicator after animation
            setTimeout(() => {
                elements.tapIndicator.style.opacity = '0';
            }, 300);
        });

        function loginUser(username) {
            gameState.currentPlayer = username;
            elements.playerName.textContent = username;
            elements.authScreen.style.display = 'none';
            elements.gameScreen.style.display = 'block';
            
            // Initialize game dimensions
            initGameDimensions();
            
            // Initialize game
            initGame();
            
            // Connect to "server" (simulated with localStorage)
            connectToServer();
        }

        function logoutUser() {
            gameState.currentPlayer = null;
            elements.authScreen.style.display = 'block';
            elements.gameScreen.style.display = 'none';
            
            // Clear game state
            clearInterval(gameState.gameLoopInterval);
            elements.worldContainer.innerHTML = '';
        }

        function connectToServer() {
            // Simulate WebSocket with localStorage and polling
            gameState.socket = {
                send: (data) => {
                    // In a real app, this would send data to the server
                    // Here we'll just process it locally
                    processServerMessage({ data: JSON.stringify(data) });
                }
            };
            
            // Start polling for updates
            setInterval(() => {
                const updates = JSON.parse(localStorage.getItem('worm-wars-updates') || '[]');
                if (updates.length > 0) {
                    updates.forEach(processServerMessage);
                    localStorage.setItem('worm-wars-updates', JSON.stringify([]));
                }
            }, 100);
            
            // Send join message
            gameState.socket.send({
                type: 'join',
                username: gameState.currentPlayer
            });
        }

        function processServerMessage(message) {
            const data = JSON.parse(message.data);
            
            switch (data.type) {
                case 'init':
                    gameState.playerId = data.playerId;
                    gameState.players = data.players;
                    gameState.foods = data.foods;
                    renderGame();
                    startGameLoop();
                    updateLeaderboard();
                    updateFoodCount();
                    break;
                    
                case 'update':
                    gameState.players = data.players;
                    gameState.foods = data.foods;
                    updateLeaderScore();
                    updateFoodCount();
                    break;
                    
                case 'leaderboard':
                    updateLeaderboard(data.leaderboard);
                    break;
            }
        }

        function initGame() {
            // Generate random player ID
            gameState.playerId = 'player-' + Math.random().toString(36).substr(2, 9);
            
            // Initialize player at random position in the world
            const startX = Math.floor(Math.random() * (WORLD_SIZE - 200)) + 100;
            const startY = Math.floor(Math.random() * (WORLD_SIZE - 200)) + 100;
            
            gameState.players[gameState.playerId] = {
                username: gameState.currentPlayer,
                segments: [
                    { x: startX, y: startY },
                    { x: startX - 20, y: startY },
                    { x: startX - 40, y: startY }
                ],
                direction: 'right',
                score: 0,
                color: getRandomColor()
            };
            
            // Center camera on player
            centerCameraOnPlayer();
            
            // Generate abundant initial food
            generateFood(INITIAL_FOOD);
            updateFoodCount();
            
            // Start game loop
            startGameLoop();
        }

        function startGameLoop() {
            if (gameState.gameLoopInterval) {
                clearInterval(gameState.gameLoopInterval);
            }
            
            gameState.gameLoopInterval = setInterval(() => {
                updateGame();
                renderGame();
                
                // Send update to "server"
                if (gameState.socket) {
                    gameState.socket.send({
                        type: 'move',
                        playerId: gameState.playerId,
                        direction: gameState.direction,
                        segments: gameState.players[gameState.playerId].segments,
                        score: gameState.players[gameState.playerId].score
                    });
                }
            }, 100);
        }

        function updateGame() {
            const player = gameState.players[gameState.playerId];
            if (!player) return;
            
            const head = { ...player.segments[0] };
            
            // Calculate direction based on target position if one exists
            if (gameState.targetPosition) {
                const dx = gameState.targetPosition.x - head.x;
                const dy = gameState.targetPosition.y - head.y;
                
                // Only change direction if we're not already moving directly toward target
                if (Math.abs(dx) > Math.abs(dy)) {
                    gameState.targetDirection = dx > 0 ? 'right' : 'left';
                } else {
                    gameState.targetDirection = dy > 0 ? 'down' : 'up';
                }
                
                // Don't allow immediate reverse direction
                if (
                    !(gameState.direction === 'up' && gameState.targetDirection === 'down') &&
                    !(gameState.direction === 'down' && gameState.targetDirection === 'up') &&
                    !(gameState.direction === 'left' && gameState.targetDirection === 'right') &&
                    !(gameState.direction === 'right' && gameState.targetDirection === 'left')
                ) {
                    gameState.direction = gameState.targetDirection;
                }
                
                // Clear target if we're very close
                if (Math.sqrt(dx*dx + dy*dy) < 20) {
                    gameState.targetPosition = null;
                }
            }
            
            // Move the worm based on current direction
            switch (gameState.direction) {
                case 'up':
                    head.y -= 20;
                    break;
                case 'down':
                    head.y += 20;
                    break;
                case 'left':
                    head.x -= 20;
                    break;
                case 'right':
                    head.x += 20;
                    break;
            }
            
            // Check world boundaries (wrap around)
            if (head.x < 0) head.x = WORLD_SIZE - 20;
            if (head.x >= WORLD_SIZE) head.x = 0;
            if (head.y < 0) head.y = WORLD_SIZE - 20;
            if (head.y >= WORLD_SIZE) head.y = 0;
            
            // Check for collisions with food
            let ateFood = false;
            gameState.foods = gameState.foods.filter(food => {
                const distance = Math.sqrt(Math.pow(food.x - head.x, 2) + Math.pow(food.y - head.y, 2));
                if (distance < 18) {
                    ateFood = true;
                    player.score += 10;
                    elements.playerScore.textContent = player.score;
                    return false;
                }
                return true;
            });
            
            // Add new head
            player.segments.unshift(head);
            
            // If didn't eat food, remove tail
            if (!ateFood) {
                player.segments.pop();
            } else {
                // Generate multiple new food items when one is eaten
                generateFood(FOOD_PER_EAT);
                updateFoodCount();
                
                // Update high score if needed
                if (player.score > database.users[gameState.currentPlayer].highScore) {
                    database.users[gameState.currentPlayer].highScore = player.score;
                    localStorage.setItem('worm-wars-users', JSON.stringify(database.users));
                    updateLeaderboard();
                }
            }
            
            // Check for collisions with self
            for (let i = 4; i < player.segments.length; i++) {
                if (player.segments[i].x === head.x && player.segments[i].y === head.y) {
                    // Game over
                    resetPlayer();
                    break;
                }
            }
            
            // Update camera position to follow player
            centerCameraOnPlayer();
            
            // Update player position display
            elements.playerPosition.textContent = `${head.x}, ${head.y}`;
        }

        function centerCameraOnPlayer() {
            const player = gameState.players[gameState.playerId];
            if (!player || !player.segments.length) return;
            
            const head = player.segments[0];
            
            // Calculate new camera position to center on player
            gameState.camera.x = head.x - gameState.viewportWidth / 2;
            gameState.camera.y = head.y - gameState.viewportHeight / 2;
            
            // Update world container position
            elements.worldContainer.style.transform = `translate(${-gameState.camera.x}px, ${-gameState.camera.y}px)`;
            
            // Update minimap
            updateMinimap();
        }

        function updateMinimap() {
            // Update viewport indicator on minimap
            const viewportWidth = gameState.viewportWidth * MINIMAP_SCALE;
            const viewportHeight = gameState.viewportHeight * MINIMAP_SCALE;
            
            elements.viewportIndicator.style.width = `${viewportWidth}px`;
            elements.viewportIndicator.style.height = `${viewportHeight}px`;
            elements.viewportIndicator.style.left = `${gameState.camera.x * MINIMAP_SCALE}px`;
            elements.viewportIndicator.style.top = `${gameState.camera.y * MINIMAP_SCALE}px`;
            
            // Update minimap scale
            elements.minimap.style.transform = `scale(${MINIMAP_SCALE})`;
        }

        function updateFoodCount() {
            elements.foodCount.textContent = gameState.foods.length;
        }

        function resetPlayer() {
            const player = gameState.players[gameState.playerId];
            const startX = Math.floor(Math.random() * (WORLD_SIZE - 200)) + 100;
            const startY = Math.floor(Math.random() * (WORLD_SIZE - 200)) + 100;
            
            player.segments = [
                { x: startX, y: startY },
                { x: startX - 20, y: startY },
                { x: startX - 40, y: startY }
            ];
            player.direction = 'right';
            gameState.direction = 'right';
            gameState.targetDirection = 'right';
            gameState.targetPosition = null;
            player.score = 0;
            elements.playerScore.textContent = '0';
            
            // Center camera on new position
            centerCameraOnPlayer();
        }

        function generateFood(count) {
            for (let i = 0; i < count; i++) {
                // Generate food more likely to appear near players
                let x, y;
                if (Math.random() < 0.7 && Object.keys(gameState.players).length > 0) {
                    // 70% chance to spawn near a player
                    const playerIds = Object.keys(gameState.players);
                    const randomPlayerId = playerIds[Math.floor(Math.random() * playerIds.length)];
                    const player = gameState.players[randomPlayerId];
                    const head = player.segments[0];
                    
                    // Spawn within 2000px of a player's head
                    x = head.x + (Math.random() * 4000 - 2000);
                    y = head.y + (Math.random() * 4000 - 2000);
                    
                    // Ensure coordinates are within world bounds
                    x = (x + WORLD_SIZE) % WORLD_SIZE;
                    y = (y + WORLD_SIZE) % WORLD_SIZE;
                } else {
                    // 30% chance to spawn anywhere in the world
                    x = Math.floor(Math.random() * (WORLD_SIZE / 20)) * 20;
                    y = Math.floor(Math.random() * (WORLD_SIZE / 20)) * 20;
                }
                
                gameState.foods.push({
                    x: x,
                    y: y,
                    color: getRandomColor()
                });
            }
            updateFoodCount();
        }

        function renderGame() {
            // Clear the world container
            elements.worldContainer.innerHTML = '';
            
            // Render food (only what's in or near viewport for performance)
            const renderDistance = Math.max(gameState.viewportWidth, gameState.viewportHeight) * 1.5;
            
            gameState.foods.forEach(food => {
                // Only render food that's within render distance of the viewport
                if (
                    food.x >= gameState.camera.x - renderDistance && 
                    food.x <= gameState.camera.x + gameState.viewportWidth + renderDistance &&
                    food.y >= gameState.camera.y - renderDistance &&
                    food.y <= gameState.camera.y + gameState.viewportHeight + renderDistance
                ) {
                    const foodElement = document.createElement('div');
                    foodElement.className = 'food';
                    foodElement.style.left = `${food.x}px`;
                    foodElement.style.top = `${food.y}px`;
                    foodElement.style.backgroundColor = food.color;
                    elements.worldContainer.appendChild(foodElement);
                }
            });
            
            // Render players
            Object.keys(gameState.players).forEach(playerId => {
                const player = gameState.players[playerId];
                
                // Render segments (only what's in or near viewport)
                player.segments.forEach((segment, index) => {
                    // Only render segments that are within render distance of the viewport
                    if (
                        segment.x >= gameState.camera.x - renderDistance && 
                        segment.x <= gameState.camera.x + gameState.viewportWidth + renderDistance &&
                        segment.y >= gameState.camera.y - renderDistance &&
                        segment.y <= gameState.camera.y + gameState.viewportHeight + renderDistance
                    ) {
                        const segmentElement = document.createElement('div');
                        segmentElement.className = index === 0 ? 'worm-head' : 'worm';
                        segmentElement.style.left = `${segment.x}px`;
                        segmentElement.style.top = `${segment.y}px`;
                        segmentElement.style.backgroundColor = player.color;
                        
                        if (index === 0) {
                            // Add player name above head (only if in viewport)
                            if (isInViewport(segment.x, segment.y)) {
                                const nameTag = document.createElement('div');
                                nameTag.textContent = player.username;
                                nameTag.style.position = 'absolute';
                                nameTag.style.left = `${segment.x}px`;
                                nameTag.style.top = `${segment.y - 25}px`;
                                nameTag.style.color = player.color;
                                nameTag.style.fontWeight = 'bold';
                                nameTag.style.textShadow = '1px 1px 1px black';
                                nameTag.style.whiteSpace = 'nowrap';
                                elements.worldContainer.appendChild(nameTag);
                            }
                        }
                        
                        elements.worldContainer.appendChild(segmentElement);
                    }
                });
            });
        }

        function isInViewport(x, y) {
            return (
                x >= gameState.camera.x - 50 && 
                x <= gameState.camera.x + gameState.viewportWidth + 50 &&
                y >= gameState.camera.y - 50 &&
                y <= gameState.camera.y + gameState.viewportHeight + 50
            );
        }

        function updateLeaderScore() {
            let maxScore = 0;
            Object.values(gameState.players).forEach(player => {
                if (player.score > maxScore) {
                    maxScore = player.score;
                }
            });
            elements.leaderScore.textContent = maxScore;
        }

        function updateLeaderboard() {
            // Get all users with their high scores
            const leaderboard = [];
            for (const username in database.users) {
                leaderboard.push({
                    username,
                    highScore: database.users[username].highScore
                });
            }
            
            // Sort by score (descending)
            leaderboard.sort((a, b) => b.highScore - a.highScore);
            
            // Update the table
            elements.leaderboardBody.innerHTML = '';
            leaderboard.slice(0, 10).forEach((user, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${user.username}</td>
                    <td>${user.highScore}</td>
                `;
                elements.leaderboardBody.appendChild(row);
            });
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (gameState.currentPlayer) {
                initGameDimensions();
                centerCameraOnPlayer();
            }
        });

        // Initialize leaderboard
        updateLeaderboard();
    </script>
</body>
</html>
